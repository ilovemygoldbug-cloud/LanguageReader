<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Language Reader</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin="anonymous" src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin="anonymous" src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html{ text-size-adjust:100%; -webkit-text-size-adjust:100%; }
    kbd{background:#eee;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:3px;padding:0 4px;font-size:.8em}
    .token{display:inline-block;margin-right:.15em}
    /* Story highlights by status */
    .w0{background:#fee2e2} /* very light red for Ignored */
    .w1{background:#bfdbfe} /* blue-200 for New */
    .w2{background:#fde68a} /* yellow-300 for Seen */
    .w3{background:#bbf7d0} /* green-200 for Familiar */

    /* >>> NEW: phrase underline that doesn't affect token colors <<< */
    .phrase-underline{
      text-decoration-line: underline;
      text-decoration-style: dashed;
      text-decoration-color: #6b7280; /* neutral gray */
      text-underline-offset: 0.2em;
      text-decoration-thickness: 1px;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div id="root"></div>
  <script type="text/babel" data-presets="env,react">
    const {useEffect,useMemo,useRef,useState} = React;

    // ---- Utils ----
    // 0..4: 0=Ignored, 1=New, 2=Seen, 3=Familiar, 4=Known
    const clamp04 = n => Math.max(0, Math.min(4, Math.floor(Number(n ?? 1))));
    function nfcLower(s){ try{return (s||'').normalize('NFC').toLowerCase();}catch{return (s||'').toLowerCase();} }
    const isWord = t => /[\p{L}\p{M}\p{N}]/u.test(t||'');

    /* >>> NEW: build phrase list from multi-word lexicon keys <<< */
    function phrasesFromLexMap(map){
      if (!map || map.size === 0) return [];
      const out = [];
      map.forEach((_, key) => {
        if (!key || !key.includes(' ')) return;
        const bits = key.split(/\s+/).map(nfcLower).filter(Boolean);
        if (bits.length > 1) out.push(bits);
      });
      // de-dup
      const seen = new Set();
      return out.filter(arr => {
        const k = arr.join(' ');
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      });
    }

    /* >>> NEW: mark which token indexes are inside any phrase (greedy, longest-first) <<< */
    function markPhraseTokens(norms, phrases){
      const byHead = new Map();
      for (const p of phrases){
        if (!p || !p.length) continue;
        const h = p[0];
        if (!byHead.has(h)) byHead.set(h, []);
        byHead.get(h).push(p);
      }
      for (const list of byHead.values()) list.sort((a,b)=>b.length - a.length);

      const inPhrase = Array(norms.length).fill(false);
      let i = 0;
      while (i < norms.length){
        const cand = byHead.get(norms[i]);
        if (!cand){ i++; continue; }

        let matched = null;
        for (const p of cand){
          let ok = true;
          for (let k=0; k<p.length; k++){
            if (i+k >= norms.length || norms[i+k] !== p[k]) { ok=false; break; }
          }
          if (ok){ matched = p; break; }
        }
        if (matched){
          for (let k=0; k<matched.length; k++) inPhrase[i+k] = true;
          i += matched.length; // skip past the phrase (avoids overlap noise)
        } else {
          i++;
        }
      }
      return inPhrase;
    }

    function normStatus(s){
      if (typeof s === 'string') {
        const v = s.trim().toLowerCase();
        if (v === 'ignore' || v === 'ignored' || v === 'name' || v === 'proper') return 0;
        if (v === 'new') return 1;
        if (v === 'seen') return 2;
        if (v === 'familiar') return 3;
        if (v === 'known') return 4;
        if (/^\d$/.test(v)) return clamp04(v);
      }
      return clamp04(s);
    }

    // Prefer meta.language if present in the lexicon file
    function extractMetaLang(jsonText){
      try {
        const j = JSON.parse((jsonText||'').replace(/^\uFEFF/,''));
        const m = j && j.meta && (j.meta.language || j.meta.lang || j.language);
        return (typeof m === 'string' && m.trim()) ? m.trim() : null;
      } catch { return null; }
    }
    // Also read meta.glossLang (language of definitions)
    function extractMetaGlossLang(jsonText){
      try{
        const j = JSON.parse((jsonText||'').replace(/^\uFEFF/,''));
        const g = j && j.meta && (j.meta.glossLang || j.meta.defLang);
        return (typeof g === 'string' && g.trim()) ? g.trim().toLowerCase() : null;
      }catch{ return null; }
    }

    // Normalize language codes to two-letter when possible (es-ES -> es)
    // IMPORTANT: return null for 'auto' so callers can decide the fallback cleanly.
    function normalizeLangCode(code){
      if (!code) return null;
      const c = String(code).trim().toLowerCase();
      if (c === 'auto') return null;            // don't turn 'auto' into 'au'
      if (c.startsWith('pt-br')) return 'pt';
      if (c.startsWith('zh')) return 'zh';
      if (/^[a-z]{2}(-[a-z]{2})?$/.test(c)) return c.slice(0,2);
      return c.length >= 2 ? c.slice(0,2) : c;
    }

    // Given UI selection + detected code, pick what to send to DeepL
    function pickDeepLSource(sourceLang, detectedLang){
      const chosen = (sourceLang && sourceLang !== 'auto') ? sourceLang : detectedLang;
      const norm = normalizeLangCode(chosen);
      return norm || 'auto'; // only 'auto' if we genuinely have no detected code
    }

    // Human-readable name from lang code (es -> Spanish)
    const LANGUAGE_NAMES = {
      'en':'English','es': 'Spanish', 'fr': 'French', 'de': 'German', 'it': 'Italian', 'pt': 'Portuguese',
      'ru': 'Russian', 'ja': 'Japanese', 'ko': 'Korean', 'zh': 'Chinese', 'ar': 'Arabic',
      'hi': 'Hindi', 'th': 'Thai', 'vi': 'Vietnamese', 'pl': 'Polish', 'nl': 'Dutch',
      'sv': 'Swedish', 'no': 'Norwegian', 'da': 'Danish', 'fi': 'Finnish', 'cs': 'Czech',
      'hu': 'Hungarian', 'ro': 'Romanian', 'bg': 'Bulgarian', 'hr': 'Croatian', 'sk': 'Slovak',
      'sl': 'Slovenian', 'et': 'Estonian', 'lv': 'Latvian', 'lt': 'Lithuanian', 'el': 'Greek',
      'tr': 'Turkish', 'he': 'Hebrew', 'fa': 'Persian', 'ur': 'Urdu', 'bn': 'Bengali',
      'ta': 'Tamil', 'te': 'Telugu', 'ml': 'Malayalam', 'kn': 'Kannada', 'gu': 'Gujarati',
      'pa': 'Punjabi', 'mr': 'Marathi', 'ne': 'Nepali', 'si': 'Sinhala', 'my': 'Burmese',
      'km': 'Khmer', 'lo': 'Lao', 'ka': 'Georgian', 'am': 'Amharic', 'sw': 'Swahili',
      'zu': 'Zulu', 'af': 'Afrikaans', 'sq': 'Albanian', 'eu': 'Basque', 'be': 'Belarusian',
      'bs': 'Bosnian', 'br': 'Breton', 'ca': 'Catalan', 'co': 'Corsican', 'cy': 'Welsh',
      'eo': 'Esperanto', 'fo': 'Faroese', 'fy': 'Frisian', 'ga': 'Irish', 'gd': 'Scottish Gaelic',
      'gl': 'Galician', 'is': 'Icelandic', 'lb': 'Luxembourgish', 'mt': 'Maltese', 'mk': 'Macedonian',
      'mn': 'Mongolian', 'sr': 'Serbian', 'uk': 'Ukrainian', 'uz': 'Uzbek', 'kk': 'Kazakh',
      'ky': 'Kyrgyz', 'tg': 'Tajik', 'tk': 'Turkmen', 'az': 'Azerbaijani', 'hy': 'Armenian'
    };
    const prettyLangName = code => (LANGUAGE_NAMES[code] || (code ? code : 'Auto'));

    // ---- Language Detection (heuristic fallback) ----
    function detectLanguageFromLexicon(lexMap) {
      if (!lexMap || lexMap.size === 0) return null;
      const entries = Array.from(lexMap.values()).slice(0, 50);
      const text = entries.map(e => e.term || e.spanish || e.word || '').join(' ').toLowerCase();
      if (/[àáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ]/.test(text)) {
        if (/[ñáéíóúü]/.test(text)) return 'es';
        if (/[âêîôûàèùç]/.test(text)) return 'fr';
        if (/[äöüß]/.test(text)) return 'de';
        if (/[àèìòù]/.test(text)) return 'it';
        if (/[ãõç]/.test(text)) return 'pt';
      }
      if (/[א-ת]/.test(text)) return 'he';
      if (/[а-я']/.test(text)) return 'ru';
      if (/[一-龯]/.test(text)) return 'zh';
      if (/[ひらがなカタカナ一-龯]/.test(text)) return 'ja';
      if (/[가-힣]/.test(text)) return 'ko';
      if (/[ا-ي]/.test(text)) return 'ar';
      if (/[ก-๎]/.test(text)) return 'th';
      return null;
    }

    // ---- UI helpers ----
    function statusLabel(s){
      const n = clamp04(s);
      return (n===0)? 'Ignored'
           : (n===1)? 'New'
           : (n===2)? 'Seen'
           : (n===3)? 'Familiar'
           : 'Known';
    }
    function statusPillClass(s){
      const n = clamp04(s);
      return (n===0)? 'bg-rose-50 text-rose-700 border-rose-200'
           : (n===1)? 'bg-blue-100 text-blue-800 border-blue-300'
           : (n===2)? 'bg-yellow-100 text-yellow-800 border-yellow-300'
           : (n===3)? 'bg-green-100 text-green-800 border-green-300'
           : 'bg-white text-gray-800 border-gray-300';
    }

    function deepLURL(text, source='auto', target='en'){
      return `https://www.deepl.com/translator#${encodeURIComponent(source)}/${encodeURIComponent(target)}/${encodeURIComponent(String(text||'').trim())}`;
    }

    // ---- Flexible text parser ----
    function tokenizeFromText(s){
      return String(s||'').match(/[\p{L}\p{M}\p{N}]+|[¿¡"'"()«»\[\]\-—–,…,:;.!?]/gu) || [];
    }
    function parseFlexible(text){
      const trimmed=(text||'').replace(/^\uFEFF/,'').trim();
      if(!trimmed) return [];
      try{
        const data=JSON.parse(trimmed);
        if(Array.isArray(data)){
          const out=[];
          data.forEach((it,i)=>{
            if(it && Array.isArray(it.tokens)) out.push({sid:it.sid||`j:${i+1}`, tokens: it.tokens.map(String)});
            else if(it && typeof it.text==='string') out.push({sid:it.sid||`jt:${i+1}`, tokens: tokenizeFromText(it.text)});
          });
          if(out.length) return out;
        }
        if(data && Array.isArray(data.sentences)){
          const out=[];
          data.sentences.forEach((it,i)=>{
            if(it && Array.isArray(it.tokens)) out.push({sid:it.sid||`js:${i+1}`, tokens: it.tokens.map(String)});
            else if(it && typeof it.text==='string') out.push({sid:it.sid||`js:${i+1}`, tokens: tokenizeFromText(it.text)});
          });
          if(out.length) return out;
        }
        if(data && Array.isArray(data.tokens)) return [{sid:data.sid||'j:1', tokens:data.tokens.map(String)}];
        if(data && typeof data.text==='string') return [{sid:data.sid||'jt:1', tokens: tokenizeFromText(data.text)}];
      }catch{}
      // JSONL
      const out=[]; let hit=false;
      trimmed.split(/\r?\n/).forEach((line,i)=>{
        const ln=line.trim(); if(!ln) return;
        try{
          const obj=JSON.parse(ln);
          if(obj && Array.isArray(obj.tokens)){ out.push({sid:obj.sid||`l:${out.length+1}`, tokens: obj.tokens.map(String)}); hit=true; }
          else if(obj && typeof obj.text==='string'){ out.push({sid:obj.sid||`lt:${out.length+1}`, tokens: tokenizeFromText(obj.text)}); hit=true; }
        }catch{}
      });
      if(hit) return out;
      // Plaintext
      const parts = trimmed.split(/([.!?\u2026]+)\s+/);
      const sents=[];
      for(let i=0;i<parts.length;i+=2){
        const body=(parts[i]||'').trim();
        const end=(parts[i+1]||'').trim();
        const sent=(body + (end?(' '+end):'')).trim();
        if(!sent) continue;
        sents.push({sid:`pt:${sents.length+1}`, tokens: tokenizeFromText(sent)});
      }
      return sents;
    }

    // ---- Lexicon ----
    function parseLexiconJSON(text){
      const obj=JSON.parse((text||'').replace(/^\uFEFF/,''));
      const map=new Map();
      let entries = [];
      if (Array.isArray(obj && obj.entries)) {
        entries = obj.entries;
      } else if (Array.isArray(obj)) {
        entries = obj;
      } else if (obj && typeof obj === 'object') {
        entries = Object.keys(obj).map(key => ({
          term: key,
          word: key,
          spanish: key,
          ...obj[key]
        }));
      }
      for(const e of entries){
        if(!e) continue;
        const word = e.term || e.word || e.spanish || e.source || '';
        if (!word) continue;
        const key=nfcLower(word);
        const english = Array.isArray(e.english)? e.english.map(String) 
                      : Array.isArray(e.translation)? e.translation.map(String)
                      : Array.isArray(e.definitions)? e.definitions.map(String)
                      : (e.english || e.translation || e.definition)? [String(e.english || e.translation || e.definition)] 
                      : [];
        map.set(key, { 
          term: word, 
          spanish: word,
          word: word,
          english, 
          status: normStatus(e.status), 
          scope: e.scope||'form', 
          notes: e.notes||'' 
        });
      }
      return map;
    }

    function exportLexiconJSON(map, detectedLang = null, glossLang = null){
      const entries=Array.from(map.values()).sort((a,b)=>{
        const wordA = a.word || a.term || a.spanish || '';
        const wordB = b.word || b.term || b.spanish || '';
        return wordA.localeCompare(wordB, detectedLang || 'en', {sensitivity:'base'});
      });
      return JSON.stringify({ 
        meta: { source: 'unified', version: 2, language: detectedLang || 'auto', glossLang: glossLang || null }, 
        entries: entries.map(e => ({
          term: e.word || e.term || e.spanish,
          english: e.english,
          status: e.status,
          scope: e.scope,
          notes: e.notes
        }))
      }, null, 2);
    }

    // ---- Components ----
    function FilePicker({label,accept,onPick}){
      const ref=React.useRef(null);
      return (
        <div className="inline-flex items-center gap-2">
          <button className="px-3 py-2 rounded-xl shadow border border-gray-300 hover:bg-gray-50" onClick={()=>ref.current?.click()}>{label}</button>
          <input ref={ref} type="file" accept={accept} className="hidden" onChange={async e=>{
            const f=e.target.files?.[0]; if(!f) return;
            const txt=await f.text(); onPick({text:txt,name:f.name}); e.target.value='';
          }}/>
        </div>
      );
    }

    function LanguageSelector({value, onChange, detectedLang}){
      const languages = [
        ['auto', 'Auto-detect'],
        ['es', 'Spanish'], ['fr', 'French'], ['de', 'German'], ['it', 'Italian'], ['pt', 'Portuguese'],
        ['ru', 'Russian'], ['ja', 'Japanese'], ['ko', 'Korean'], ['zh', 'Chinese'], ['ar', 'Arabic'],
        ['hi', 'Hindi'], ['th', 'Thai'], ['vi', 'Vietnamese'], ['pl', 'Polish'], ['nl', 'Dutch'],
        ['sv', 'Swedish'], ['no', 'Norwegian'], ['da', 'Danish'], ['fi', 'Finnish'], ['tr', 'Turkish'],
        ['en', 'English']
      ];
      return (
        <div className="flex flex-col gap-1">
          <select 
            value={value} 
            onChange={e => onChange(e.target.value)}
            className="border rounded px-2 py-1 text-sm"
          >
            {languages.map(([code, name]) => (
              <option key={code} value={code}>{name}</option>
            ))}
          </select>
          {detectedLang && (
            <div className="text-xs text-green-600">
              Detected: {LANGUAGE_NAMES[detectedLang] || detectedLang}
            </div>
          )}
        </div>
      );
    }

    function TargetDisplay({ glossLang }) {
      return (
        <div className="flex items-center gap-2 text-sm">
          <span className="text-gray-600">Translate to:</span>
          <span className="px-2 py-1 rounded border bg-gray-50">
            {LANGUAGE_NAMES[glossLang] || glossLang || 'en'}
          </span>
        </div>
      );
    }

    function TokenPopup({anchorEl, token, entry, glossLang, onClose, onSetStatus, onSaveEnglish, onSaveNotes, onOpenDeepL}){
      const ref=useRef(null);
      const [pos,setPos]=useState({top:0,left:0});
      const [defs,setDefs]=useState((entry.english||[]).join("\n"));
      const [notes,setNotes]=useState(entry.notes||'');
      useEffect(()=>{ setDefs((entry.english||[]).join("\n")); setNotes(entry.notes||''); }, [entry.spanish, entry.word, entry.term]);

      useEffect(()=>{
        if(!anchorEl || !ref.current) return;
        const a=anchorEl.getBoundingClientRect(), p=ref.current.getBoundingClientRect(), m=8;
        let left=a.left+a.width/2-p.width/2; left=Math.max(m,Math.min(left, innerWidth-p.width-m));
        let top=a.bottom+m; if(top+p.height>innerHeight-m) top=Math.max(m, a.top-p.height-m);
        setPos({top,left});
      }, [anchorEl, token]);

      useEffect(()=>{
        const onKey=e=>{
          const tag=(e.target?.tagName||'').toUpperCase();
          if(tag==='INPUT'||tag==='TEXTAREA'||e.target?.isContentEditable) return;
          if(e.key==='Escape') onClose();
          if(['0','1','2','3','4'].includes(e.key)) onSetStatus(Number(e.key));
        };
        addEventListener('keydown', onKey);
        return ()=>removeEventListener('keydown', onKey);
      }, [onClose, onSetStatus]);

      return (
        <div ref={ref} className="fixed z-50 bg-white rounded-xl shadow-lg border p-3 text-sm w-[28rem]" style={{top:pos.top,left:pos.left}}>
          <div className="font-semibold mb-2 flex items-center gap-2">Word: <i>{token}</i> <span className={"px-2 py-0.5 rounded border text-xs "+statusPillClass(entry.status)}>{statusLabel(entry.status)}</span></div>
          <div className="flex flex-wrap gap-2 mb-2">
            <button className="px-2 py-1 rounded border hover:bg-gray-50" onClick={()=>onSetStatus(0)}>Ignore</button>
            {[1,2,3,4].map(s=>(
              <button key={s} className="px-2 py-1 rounded border hover:bg-gray-50" onClick={()=>onSetStatus(s)}>
                {['New','Seen','Familiar','Known'][s-1]}
              </button>
            ))}
          </div>
          <div className="mt-2 p-2 rounded border bg-gray-50">
            <div className="flex items-center justify-between mb-1">
              <div className="font-medium">
                Definitions {glossLang ? `(${prettyLangName(glossLang)})` : ''}
              </div>
              <div className="flex gap-2">
                <button className="px-2 py-1 rounded border hover:bg-white" onClick={onOpenDeepL} title="Open DeepL in new tab">Lookup</button>
                <button className="px-2 py-1 rounded border hover:bg-white" onClick={async()=>{
                  try{
                    const txt=await navigator.clipboard.readText();
                    if(txt && txt.trim()){
                      const lines=(defs?defs.split("\n").map(x=>x.trim()).filter(Boolean):[]);
                      if(!lines.includes(txt.trim())) lines.push(txt.trim());
                      setDefs(lines.join("\n"));
                      onSaveEnglish(lines.join("\n"));
                    }
                  }catch{ alert('Clipboard read failed. Copy in DeepL, then press Ctrl+V here.'); }
                }}>Paste from clipboard</button>
              </div>
            </div>
            <textarea className="w-full border rounded px-2 py-1 text-sm" rows="5"
              value={defs} onChange={e=>setDefs(e.target.value)} onBlur={()=>onSaveEnglish(defs)}
              placeholder="Add one meaning per line"></textarea>
            <div className="mt-2">
              <label className="text-xs text-gray-600">Notes</label>
              <input className="w-full border rounded px-2 py-1 text-sm" value={notes} onChange={e=>setNotes(e.target.value)} onBlur={()=>onSaveNotes(notes)} />
            </div>
          </div>
          <div className="text-right mt-2"><button className="px-2 py-1 rounded border hover:bg-gray-50" onClick={onClose}>Close</button></div>
          <div className="text-xs text-gray-500 mt-1">Hotkeys: 0 Ignore • 1 New • 2 Seen • 3 Familiar • 4 Known • Esc Close</div>
        </div>
      );
    }

    function App(){
      const [sentences,setSentences]=useState([]);
      const [lexMap,setLexMap]=useState(new Map());
      const [lexHandle,setLexHandle]=useState(null);
      const [lexName,setLexName]=useState('');
      const [sourceLang,setSourceLang]=useState('auto');
      //const [targetLang,setTargetLang]=useState('en');
      const [detectedLang,setDetectedLang]=useState(null);
      const [glossLang,setGlossLang]=useState(null);
      const [active,setActive]=useState(null); // {s,t} or {selectedText}
      const [selectedText,setSelectedText]=useState('');
      const [textName, setTextName] = useState('');
      const tokenRefs=useRef(new Map());

      // Hidden input fallback for lexicon
      const lexInputRef = useRef(null);

      // >>> NEW: keep a derived list of phrases from the lexicon
      const lexiconPhrases = useMemo(() => phrasesFromLexMap(lexMap), [lexMap]);

      // Load cached lexicon (prefer meta.language, normalized)
      useEffect(()=>{
        const raw=localStorage.getItem('lex_cache');
        if(!raw) return;
        try{
          const map = parseLexiconJSON(raw);
          const metaLang = extractMetaLang(raw);
          const detected = normalizeLangCode(metaLang) || normalizeLangCode(detectLanguageFromLexicon(map));
          const g = extractMetaGlossLang(raw);
          setLexMap(map);
          setDetectedLang(detected || null);
          setGlossLang(normalizeLangCode(g));
          setSourceLang(prev => prev === 'auto' && detected ? detected : prev);
        }catch{}
      },[]);

      // Save cache when lexMap/detectedLang/glossLang changes
      useEffect(()=>{
        if(lexMap && lexMap.size) {
          try { localStorage.setItem('lex_cache', exportLexiconJSON(lexMap, detectedLang, glossLang)); } catch {}
        }
      },[lexMap, detectedLang, glossLang]);

      // ---- Flashcards state/helpers ----
      const [flashOpen, setFlashOpen] = useState(false);
      const [flashIdx, setFlashIdx] = useState(0);
      const familiarList = useMemo(() => {
        const arr = [];
        lexMap.forEach(e => { if (clamp04(e.status) === 3) arr.push(e); });
        arr.sort((a,b)=> (a.word||a.term||'').localeCompare(b.word||b.term||'')); 
        return arr;
      }, [lexMap]);
      const totalWords = useMemo(()=>lexMap.size, [lexMap]);
      function advanceFlash(delta=1){
        if(!familiarList.length) return;
        setFlashIdx(i => ( (i + delta) % familiarList.length + familiarList.length ) % familiarList.length);
      }
      function actOnFlash(status){
        const cur = familiarList[flashIdx];
        if(!cur) return;
        upsert(cur.word || cur.term, { status });
        if(status !== 3){
          setTimeout(()=> {
            if (familiarList.length <= 1) setFlashOpen(false);
            else setFlashIdx(i => (i >= familiarList.length - 1 ? 0 : i));
          }, 0);
        } else {
          advanceFlash(1);
        }
      }
      // Flashcard keyboard shortcuts
      useEffect(()=>{
        if(!flashOpen) return;
        const onKey = (e)=>{
          const tag=(e.target?.tagName||'').toUpperCase();
          if(tag==='INPUT'||tag==='TEXTAREA'||e.target?.isContentEditable) return;
          if(e.key==='Escape') setFlashOpen(false);
          if(e.key==='2') actOnFlash(2);
          if(e.key==='3') actOnFlash(3);
          if(e.key==='4') actOnFlash(4);
          if(e.key===']') advanceFlash(1);
          if(e.key==='[') advanceFlash(-1);
        };
        addEventListener('keydown', onKey);
        return ()=>removeEventListener('keydown', onKey);
      }, [flashOpen, flashIdx, familiarList.length]);

      // ---- Phrase collector for Alt+T (keeps spaces) ----
      function getPhraseFromSelection() {
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return '';
  const range = sel.getRangeAt(0);

  // Clone just the selected DOM and walk its text nodes.
  const frag = range.cloneContents();
  const walker = document.createTreeWalker(frag, NodeFilter.SHOW_TEXT, null);
  const parts = [];
  let n;
  while ((n = walker.nextNode())) {
    const text = String(n.nodeValue || '');
    // Keep even if whitespace-y; we’ll clean up later
    const parent = n.parentElement;
    const isToken = !!(parent && parent.classList && parent.classList.contains('token'));
    const isWordToken = isToken && parent.dataset && parent.dataset.word === '1';
    parts.push({ text, isWordToken });
  }

  const out = [];
  for (let i = 0; i < parts.length; i++) {
    const cur = parts[i];
    const prev = parts[i - 1];

    // Insert a space only when two adjacent chunks are word tokens.
    if (i > 0 && prev?.isWordToken && cur.isWordToken) out.push(' ');
    out.push(cur.text);
  }

  // Normalize internal whitespace but keep a single space between words.
  return out.join('').replace(/\s+/g, ' ').trim();
}


      // ---- Selection + Alt+T popup ----
      useEffect(()=>{
        const handleSelectionChange = () => {
          const selection = window.getSelection();
          const text = selection.toString().trim();
          setSelectedText(text);
        };
        const handleKeydown = (e) => {
  if (e.altKey && (e.key === 't' || e.key === 'T')) {
    e.preventDefault();
    const selection = window.getSelection();
    if (!selection) return;

    // Primary: robust DOM walk. Fallback: plain toString.
    let text = getPhraseFromSelection();
    if (!text) text = selection.toString().trim();
    if (!text) return;

    // Try to get a reliable rect for anchoring the popup.
    let rect = null;
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const rects = range.getClientRects?.();
      rect = (rects && rects.length ? rects[0] : range.getBoundingClientRect());
    }
    if (!rect || !(rect.width || rect.height)) {
      // Last resort: center anchor so the popup still shows.
      rect = { left: innerWidth / 2, top: innerHeight / 2, width: 0, height: 0, right: innerWidth / 2, bottom: innerHeight / 2 };
    }

    const fakeAnchor = { getBoundingClientRect: () => rect };
    setActive({ s: -1, t: -1, selectedText: text, anchorEl: fakeAnchor });
  }
};

        document.addEventListener('selectionchange', handleSelectionChange);
        document.addEventListener('keydown', handleKeydown);
        return () => {
          document.removeEventListener('selectionchange', handleSelectionChange);
          document.removeEventListener('keydown', handleKeydown);
        };
      }, []);

      // ---- Lexicon open: FS API first, fallback to input ----
      async function handleLexFilePicked(file){
        resetLexiconState();
        const txt = await file.text();
        const map = parseLexiconJSON(txt);
        const metaLang = extractMetaLang(txt);
        const detected = normalizeLangCode(metaLang);
        const g = extractMetaGlossLang(txt);
        setLexMap(map);
        setLexName(file.name);
        setDetectedLang(detected || null);
        setGlossLang(normalizeLangCode(g));
        setLexHandle(null);
        try { localStorage.setItem('lex_cache', txt); } catch {}
      }

      async function openLexicon(){
        try{
          resetLexiconState();
          if(!window.showOpenFilePicker) throw new Error('No FS API');
          const [h] = await window.showOpenFilePicker({
            types: [{ description:'JSON', accept:{ 'application/json':['.json'] } }],
            multiple: false,
            excludeAcceptAllOption: true
          });
          const file = await h.getFile();
          const txt = await file.text();
          const map = parseLexiconJSON(txt);
          const metaLang = extractMetaLang(txt);
          const detected = normalizeLangCode(metaLang);
          const g = extractMetaGlossLang(txt);
          setLexMap(map);
          setLexHandle(h);
          setLexName(file.name);
          setDetectedLang(detected || null);
          setGlossLang(normalizeLangCode(g));
          try { localStorage.setItem('lex_cache', txt); } catch {}
        } catch (e){
          lexInputRef.current?.click();
        }
      }

      // autosave (only if we have a writable handle)
      useEffect(()=>{
        if(!lexHandle) return;
        const id=setTimeout(async()=>{
          try{ const w=await lexHandle.createWritable(); await w.write(exportLexiconJSON(lexMap, detectedLang, glossLang)); await w.close(); }catch(e){ console.warn(e); }
        }, 500);
        return ()=>clearTimeout(id);
      }, [lexMap, lexHandle, detectedLang, glossLang]);

      function upsert(word, patch){
        const key=nfcLower(word);
        setLexMap(prev=>{
          const old=prev.get(key)||{term:word,spanish:word,word:word,english:[],status:1,scope:'form',notes:''};
          const next={...old, ...patch, status: clamp04((patch?.status)!=null ? patch.status : old.status)};
          const m=new Map(prev); m.set(key,next); return m;
        });
      }
      const getEntry = s => lexMap.get(nfcLower(s));

      function loadText({text,name}){ setSentences(parseFlexible(text)); setTextName(name||''); }
      function openDeepL(){
        if (!active) return;

        // Figure out the token to look up
        let tok = '';
        if (active.selectedText) {
          tok = String(active.selectedText).trim();
        } else {
          const s = sentences[active.s];
          tok = String(s?.tokens?.[active.t] ?? '').trim();
        }
        if (!tok) return;

        // Source = UI selection or detected; Target = lexicon glossLang (fallback en)
        const src = pickDeepLSource(sourceLang, detectedLang);
        const tgt = normalizeLangCode(glossLang) || 'en';

        const url = deepLURL(tok, src, tgt);
        try { window.open(url, 'deepl_lookup'); } catch {}
      }

      // Clear buttons
      function resetLexiconState(){
        setLexHandle(null);
        setLexMap(new Map());
        setDetectedLang(null);
        setGlossLang(null);
        setLexName('');
        try { localStorage.removeItem('lex_cache'); } catch {}
        setActive(null);
        setFlashOpen(false);
        setSourceLang('auto');
      }

      function clearLexicon() {
        if (!confirm('Clear the current lexicon from memory? This will also clear the cached copy. (Your file on disk will NOT be modified.)')) return;
        setLexHandle(null);
        setLexMap(new Map());
        setDetectedLang(null);
        setGlossLang(null);
        setLexName('');
        try { localStorage.removeItem('lex_cache'); } catch {}
        setActive(null);
        setFlashOpen(false);
        setSourceLang('auto');
      }

      function clearText() {
        if (!confirm('Clear the loaded text/story from the reader?')) return;
        setSentences([]);
        setTextName('');
        setActive(null);
        try { window.getSelection()?.removeAllRanges(); } catch {}
      }

      const counts = useMemo(()=>{
        const c = {0:0,1:0,2:0,3:0,4:0};
        lexMap.forEach(e => { c[clamp04(e.status)]++; });
        return c;
      }, [lexMap]);

      const currentLangName = sourceLang === 'auto' 
        ? (detectedLang ? `Auto (${LANGUAGE_NAMES[detectedLang] || detectedLang})` : 'Auto') 
        : (LANGUAGE_NAMES[sourceLang] || sourceLang);
      const deepLSourceCode = pickDeepLSource(sourceLang, detectedLang);
      const deepLSourceName = deepLSourceCode === 'auto' ? 'Auto' : prettyLangName(deepLSourceCode);
      const deepLTargetName = prettyLangName(glossLang || 'en');

      // ---- Flashcards Modal (with Reveal) ----
      function FlashcardsModal(){
        const cur = familiarList[flashIdx];
        const [revealed, setRevealed] = useState(false);
        useEffect(()=>{ setRevealed(false); }, [flashIdx, flashOpen]);

        if(!flashOpen || !cur) return null;
        const word = cur.word || cur.term || '';
        const defs = (cur.english||[]).join('\n');

        // Local key: Space to reveal
        useEffect(()=>{
          const onKey = (e)=>{
            const tag=(e.target?.tagName||'').toUpperCase();
            if(tag==='INPUT'||tag==='TEXTAREA'||e.target?.isContentEditable) return;
            if(e.key===' ' && !revealed){ e.preventDefault(); setRevealed(true); }
          };
          addEventListener('keydown', onKey);
          return ()=>removeEventListener('keydown', onKey);
        }, [revealed]);

        return (
          <div className="fixed inset-0 z-50 bg-black/40 flex items-center justify-center">
            <div className="bg-white rounded-2xl shadow-xl border w-[34rem] max-w-[90vw] p-4">
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm text-gray-600">
                  Flashcards • Familiar ({familiarList.length}) • {flashIdx+1} / {familiarList.length}
                </div>
                <button className="text-sm px-2 py-1 rounded border hover:bg-gray-50" onClick={()=>setFlashOpen(false)}>Close</button>
              </div>

              <div className="text-xl font-semibold mb-2">{word}</div>

              <div className="mb-3">
                {!revealed ? (
                  <button
                    id="reveal-btn"
                    className="px-3 py-2 rounded-xl shadow border border-gray-300 hover:bg-gray-50"
                    onClick={()=>setRevealed(true)}
                  >
                    Reveal Answer
                  </button>
                ) : (
                  <>
                    <div className="text-xs text-gray-600 mb-1">Definition(s)</div>
                    <textarea className="w-full border rounded px-2 py-1 text-sm" rows="5" value={defs} readOnly/>
                  </>
                )}
              </div>

              <div className="flex flex-wrap gap-2">
                <button className="px-3 py-1.5 rounded border hover:bg-gray-50" onClick={()=>actOnFlash(2)} title="2">Demote to Seen</button>
                <button className="px-3 py-1.5 rounded border hover:bg-gray-50" onClick={()=>actOnFlash(3)} title="3">Keep Familiar</button>
                <button className="px-3 py-1.5 rounded border hover:bg-gray-50" onClick={()=>actOnFlash(4)} title="4">Promote to Known</button>
                <div className="flex-1"></div>
                <button className="px-3 py-1.5 rounded border hover:bg-gray-50" onClick={()=>advanceFlash(-1)}>[ Prev ]</button>
                <button className="px-3 py-1.5 rounded border hover:bg-gray-50" onClick={()=>advanceFlash(1)}>[ Next ]</button>
              </div>

              <div className="text-xs text-gray-500 mt-2">
                Shortcuts: <kbd>Space</kbd> Reveal, <kbd>2</kbd> Seen, <kbd>3</kbd> Familiar, <kbd>4</kbd> Known, <kbd>[</kbd> Prev, <kbd>]</kbd> Next, <kbd>Esc</kbd> Close
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="max-w-5xl mx-auto py-6 px-4">
          <h1 className="text-2xl font-bold mb-1">Language Reader</h1>
          <p className="text-gray-600 mb-4">Click on single word or highlight a phrase and press <kbd>Alt+T</kbd> to open the translation popup.</p>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div className="rounded-xl bg-white p-4 shadow">
              <h2 className="font-semibold mb-2">Lexicon</h2>
              <div className="flex gap-2 flex-wrap items-center">
                <button className="px-3 py-2 rounded-xl shadow border border-gray-300 hover:bg-gray-50" onClick={openLexicon}>Open…</button>
                <input
                  ref={lexInputRef}
                  type="file"
                  accept=".json,application/json"
                  className="hidden"
                  onChange={async e=>{
                    const f=e.target.files?.[0];
                    if(!f) return;
                    await handleLexFilePicked(f);
                    e.target.value='';
                  }}
                />
                <button className="px-3 py-2 rounded-xl shadow border border-red-300 text-red-700 hover:bg-red-50" onClick={clearLexicon}>Clear Lexicon</button>
              </div>
              <div className="text-xs text-gray-600 mt-2">{lexName? `Loaded: ${lexName}` : 'No file open yet.'}</div>
              <>
                <div className="text-xs text-gray-600 mt-1">
                  Language: {currentLangName}
                  {` • DeepL: ${deepLSourceName} → ${deepLTargetName}`}
                </div>
                {glossLang && (
                  <div className="text-xs text-gray-600">
                    Definitions language: {LANGUAGE_NAMES[glossLang] || glossLang}
                  </div>
                )}
                <div className="mt-2">
                  <TargetDisplay glossLang={glossLang} />
                </div>
                <div className="text-xs text-gray-600 mt-2">Total words: {totalWords}</div>
                <div className="mt-2 text-xs text-gray-700 flex flex-wrap gap-2">
                  <span className="px-2 py-0.5 rounded border bg-rose-50">Ignored: {counts[0]}</span>
                  <span className="px-2 py-0.5 rounded border bg-blue-100">New: {counts[1]}</span>
                  <span className="px-2 py-0.5 rounded border bg-yellow-100">Seen: {counts[2]}</span>
                  <span className="px-2 py-0.5 rounded border bg-green-100">Familiar: {counts[3]}</span>
                  <span className="px-2 py-0.5 rounded border bg-white">Known: {counts[4]}</span>
                </div>
                <div className="mt-3">
                  <button
                    className="px-3 py-2 rounded-xl shadow border border-gray-300 hover:bg-gray-50 disabled:opacity-50"
                    onClick={()=>{ setFlashIdx(0); setFlashOpen(true); }}
                    disabled={familiarList.length === 0}
                    title={familiarList.length === 0 ? 'No familiar words yet' : 'Open flashcards'}
                  >
                    Flashcards (Familiar: {familiarList.length})
                  </button>
                </div>
              </>
            </div>

            <div className="rounded-xl bg-white p-4 shadow">
              <h2 className="font-semibold mb-2">Text</h2>
              <FilePicker label="Open text (.jsonl/.json/.txt)" accept=".json,.jsonl,.txt" onPick={loadText}/>
              <div className="text-xs text-gray-600 mt-2">
                {textName ? `Loaded: ${textName}` : 'No text open yet.'}
              </div>
              <div className="mt-2">
                <button className="px-3 py-2 rounded-xl shadow border border-red-300 text-red-700 hover:bg-red-50" onClick={clearText}>Clear Text</button>
              </div>
            </div>
          </div>

          <div className="rounded-xl bg-white p-4 shadow relative">
            {sentences.length===0 ? (
              <div className="text-gray-500">No text loaded yet.</div>
            ) : (
              <div className="space-y-4">
                {sentences.map((s,si)=>{
                  // >>> NEW: compute normalized tokens + in-phrase flags for this sentence
                  const norms = s.tokens.map(t => nfcLower(t));
                  const inPhrase = markPhraseTokens(norms, lexiconPhrases);

                  return (
                    <p key={s.sid||si} className="leading-8">
                      {s.tokens.map((t, ti) => {
                        const e=getEntry(t); 
                        const status=e? e.status:1;
                        return (
                          <span
                            key={ti}
                            ref={el=>{ if(el) tokenRefs.current.set(si+':'+ti, el); }}
                            onClick={()=>setActive({s:si,t:ti})}
                            data-word={isWord(t) ? '1' : '0'}
                            className={
                              'token px-1 rounded cursor-pointer ' +
                              (isWord(t)? (status===0?'w0':status===1?'w1':status===2?'w2':status===3?'w3':'') : '') +
                              (inPhrase[ti] ? ' phrase-underline' : '')
                            }
                          >
                            {t}
                          </span>
                        );
                      })}
                    </p>
                  );
                })}
              </div>
            )}

            {active && (()=>{ 
              let el, tok, entry;
              if (active.selectedText) {
                el = active.anchorEl;
                tok = active.selectedText;
                entry = getEntry(tok) || {term:tok,spanish:tok,word:tok,english:[],status:1,scope:'form',notes:''};
              } else {
                el = tokenRefs.current.get(active.s+':'+active.t);
                const s = sentences[active.s]; 
                tok = (s?.tokens?.[active.t])||'';
                entry = getEntry(tok) || {term:tok,spanish:tok,word:tok,english:[],status:1,scope:'form',notes:''};
              }
              return (
                <TokenPopup
                  anchorEl={el}
                  token={tok}
                  entry={entry}
                  glossLang={glossLang}
                  onClose={()=>setActive(null)}
                  onSetStatus={st=>upsert(tok,{status:st})}
                  onSaveEnglish={raw=>upsert(tok,{english:String(raw||'').split('\n').map(x=>x.trim()).filter(Boolean)})}
                  onSaveNotes={notes=>upsert(tok,{notes})}
                  onOpenDeepL={()=>{ 
                    const src = pickDeepLSource(sourceLang, detectedLang);
                    const url = deepLURL(tok, src, (normalizeLangCode(glossLang) || 'en'));
                    try { window.open(url,'deepl_lookup'); } catch {} 
                  }}
                />
              );
            })()}

            <FlashcardsModal/>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>
